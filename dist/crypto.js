(t=>{"use strict";const n="Invalid pasword",i=16,s={name:"PBKDF2"},e={name:"HMAC"},r="SHA-1",a={name:"AES-CTR"},u=Object.assign({hash:e},s),h=Object.assign({iterations:1e3,hash:{name:r}},s),o=Object.assign({hash:r},e),c=Object.assign({length:i},a),p=["deriveBits"],y=["sign"],w=528,g=10,l=[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],d=crypto.subtle;function b(t){for(let n=0;n<16;n++){if(255!=t[n]){t[n]++;break}t[n]=0}}function A(t,n){let i=t;return t.length+n.length&&(i=new Uint8Array(t.length+n.length),i.set(t,0),i.set(n,t.length)),i}function f(t,n){if(n&&n>t.length){const i=t;(t=new Uint8Array(n)).set(i,0)}return t}t.ZipDecrypt=class{constructor(t,n){this.password=t,this.signed=n,this.input=n&&new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const s=async(n=0)=>{if(n+i<r.length-g){const t=r.subarray(n,n+i),a=await d.decrypt(Object.assign({counter:this.counter},c),this.keys.decryption,t);return b(this.counter),e.set(new Uint8Array(a),n),s(n+i)}return this.pendingInput=r.subarray(n),this.signed&&(this.input=A(this.input,t)),e};if(this.password){const i=t.subarray(0,18);await async function(t,i,s){t.counter=new Uint8Array(l);const e=i.subarray(0,16),r=i.subarray(16),c=(new TextEncoder).encode(s),w=await d.importKey("raw",c,u,!1,p),g=await d.deriveBits(Object.assign({salt:e},h),w,528),b=new Uint8Array(g);if(t.keys={decryption:await d.importKey("raw",b.subarray(0,32),a,!0,["decrypt"]),authentication:await d.importKey("raw",b.subarray(32,64),o,!1,y),passwordVerification:b.subarray(64)},t.keys.passwordVerification[0]!=r[0]||t.keys.passwordVerification[1]!=r[1])throw new Error(n)}(this,i,this.password),this.password=null,t=t.subarray(18)}let e=new Uint8Array(t.length-g-(t.length-g)%i),r=t;return this.pendingInput.length&&(r=A(this.pendingInput,t),e=f(e,r.length-g-(r.length-g)%i)),s()}async flush(){const t=this.pendingInput.subarray(0,this.pendingInput.length-g),n=this.pendingInput.subarray(this.pendingInput.length-g);let i=new Uint8Array(0);if(t.length){const n=await d.decrypt(Object.assign({counter:this.counter},c),this.keys.decryption,t);i=new Uint8Array(n)}let s=!0;if(this.signed){const t=await d.sign(e,this.keys.authentication,this.input.subarray(0,this.input.length-g)),i=new Uint8Array(t);this.input=null;for(let t=0;t<g;t++)i[t]!=n[t]&&(s=!1)}return{valid:s,data:i}}},t.ZipEncrypt=class{constructor(t){this.password=t,this.output=new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const n=async(r=0)=>{if(r+i<=t.length){const a=t.subarray(r,r+i),u=await d.encrypt(Object.assign({counter:this.counter},c),this.keys.encryption,a);return b(this.counter),e.set(new Uint8Array(u),r+s.length),n(r+i)}return this.pendingInput=t.subarray(r),this.output=A(this.output,e),e};let s=new Uint8Array(0);this.password&&(s=await async function(t,n){t.counter=new Uint8Array(l);const i=crypto.getRandomValues(new Uint8Array(16)),s=(new TextEncoder).encode(n),e=await d.importKey("raw",s,u,!1,p),r=await d.deriveBits(Object.assign({salt:i},h),e,w),c=new Uint8Array(r);return t.keys={encryption:await d.importKey("raw",c.subarray(0,32),a,!0,["encrypt"]),authentication:await d.importKey("raw",c.subarray(32,64),o,!1,y),passwordVerification:c.subarray(64)},A(i,t.keys.passwordVerification)}(this,this.password),this.password=null);let e=new Uint8Array(s.length+t.length-t.length%i);return e.set(s,0),this.pendingInput.length&&(t=A(this.pendingInput,t),e=f(e,t.length-t.length%i)),n()}async flush(){let t=new Uint8Array(0);if(this.pendingInput.length){const n=await d.encrypt(Object.assign({counter:this.counter},c),this.keys.encryption,this.pendingInput);t=new Uint8Array(n),this.output=A(this.output,t)}const n=await d.sign(e,this.keys.authentication,this.output.subarray(18));this.output=null;const i=new Uint8Array(n).subarray(0,g);return{data:A(t,i),signature:i}}}})(this);
