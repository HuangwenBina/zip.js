(t=>{"use strict";const n="Invalid pasword",s=16,e={name:"PBKDF2"},r={name:"HMAC"},i="SHA-1",a={name:"AES-CTR"},u=Object.assign({hash:r},e),o=Object.assign({iterations:1e3,hash:{name:i}},e),c=Object.assign({hash:i},r),p=Object.assign({length:s},a),y=["deriveBits"],h=["sign"],l=528,w=10,g=[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];function d(t){for(let n=0;n<16;n++){if(255!=t[n]){t[n]++;break}t[n]=0}}function b(t,n){let s=t;return t.length+n.length&&(s=new Uint8Array(t.length+n.length),s.set(t,0),s.set(n,t.length)),s}function A(t,n){if(n&&n>t.length){const s=t;(t=new Uint8Array(n)).set(s,0)}return t}t.ZipDecrypt=class{constructor(t,n){this.password=t,this.signed=n,this.input=n&&new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const e=async(n=0)=>{if(n+s<i.length-w){const t=i.subarray(n,n+s),a=await crypto.subtle.decrypt(Object.assign({counter:this.counter},p),this.keys.decryption,t);return d(this.counter),r.set(new Uint8Array(a),n),e(n+s)}return this.pendingInput=i.subarray(n),this.signed&&(this.input=b(this.input,t)),r};if(this.password){const s=t.subarray(0,18);await async function(t,s,e){t.counter=new Uint8Array(g);const r=s.subarray(0,16),i=s.subarray(16),p=(new TextEncoder).encode(e),l=await crypto.subtle.importKey("raw",p,u,!1,y),w=await crypto.subtle.deriveBits(Object.assign({salt:r},o),l,528),d=new Uint8Array(w);if(t.keys={decryption:await crypto.subtle.importKey("raw",d.subarray(0,32),a,!0,["decrypt"]),authentication:await crypto.subtle.importKey("raw",d.subarray(32,64),c,!1,h),passwordVerification:d.subarray(64)},t.keys.passwordVerification[0]!=i[0]||t.keys.passwordVerification[1]!=i[1])throw new Error(n)}(this,s,this.password),this.password=null,t=t.subarray(18)}let r=new Uint8Array(t.length-w-(t.length-w)%s),i=t;return this.pendingInput.length&&(i=b(this.pendingInput,t),r=A(r,i.length-w-(i.length-w)%s)),e()}async flush(){const t=this.pendingInput.subarray(0,this.pendingInput.length-w),n=this.pendingInput.subarray(this.pendingInput.length-w);let s=new Uint8Array(0);if(t.length){const n=await crypto.subtle.decrypt(Object.assign({counter:this.counter},p),this.keys.decryption,t);s=new Uint8Array(n)}let e=!0;if(this.signed){const t=await crypto.subtle.sign(r,this.keys.authentication,this.input.subarray(0,this.input.length-w)),s=new Uint8Array(t);this.input=null;for(let t=0;t<w;t++)s[t]!=n[t]&&(e=!1)}return{valid:e,data:s}}},t.ZipEncrypt=class{constructor(t){this.password=t,this.output=new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const n=async(i=0)=>{if(i+s<=t.length){const a=t.subarray(i,i+s),u=await crypto.subtle.encrypt(Object.assign({counter:this.counter},p),this.keys.encryption,a);return d(this.counter),r.set(new Uint8Array(u),i+e.length),n(i+s)}return this.pendingInput=t.subarray(i),this.output=b(this.output,r),r};let e=new Uint8Array(0);this.password&&(e=await async function(t,n){t.counter=new Uint8Array(g);const s=crypto.getRandomValues(new Uint8Array(16)),e=(new TextEncoder).encode(n),r=await crypto.subtle.importKey("raw",e,u,!1,y),i=await crypto.subtle.deriveBits(Object.assign({salt:s},o),r,l),p=new Uint8Array(i);return t.keys={encryption:await crypto.subtle.importKey("raw",p.subarray(0,32),a,!0,["encrypt"]),authentication:await crypto.subtle.importKey("raw",p.subarray(32,64),c,!1,h),passwordVerification:p.subarray(64)},b(s,t.keys.passwordVerification)}(this,this.password),this.password=null);let r=new Uint8Array(e.length+t.length-t.length%s);return r.set(e,0),this.pendingInput.length&&(t=b(this.pendingInput,t),r=A(r,t.length-t.length%s)),n()}async flush(){let t=new Uint8Array(0);if(this.pendingInput.length){const n=await crypto.subtle.encrypt(Object.assign({counter:this.counter},p),this.keys.encryption,this.pendingInput);t=new Uint8Array(n),this.output=b(this.output,t)}const n=await crypto.subtle.sign(r,this.keys.authentication,this.output.subarray(18));this.output=null;const s=new Uint8Array(n).subarray(0,w);return{data:b(t,s),signature:s}}}})(this);
